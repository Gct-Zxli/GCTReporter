# ADR-002：SQL安全防护方案选型

| 属性 | 内容 |
|------|------|
| **ADR编号** | ADR-002 |
| **状态** | 已接受 |
| **决策日期** | 2025-12-26 |
| **决策人** | 安全审查团队 |
| **关联需求** | Epic §3.1 技术风险评估，US-002 查询安全校验 |
| **替代ADR** | 无 |

---

## 背景

### 业务需求

实现SQL查询管理模块，允许设计者自定义SQL语句。需要防止SQL注入攻击，确保数据库安全。

**来源**：Epic §2.1 模块A SQL查询管理

### 技术约束

| 约束项 | 具体内容 | 来源 |
|--------|---------|------|
| **安全等级** | 零P0级Bug（无SQL注入） | Epic §1.1 SMART目标 |
| **功能范围** | 仅允许SELECT语句 | Epic §2.1 模块A 技术难点 |
| **防护机制** | 多层防护 | Epic §3.1 风险评估 |
| **用户友好度** | 不能过度限制，影响易用性 | 基于实际经验补充 |

### 当前痛点

- SQL注入是数据库安全的首要威胁
- 传统黑名单容易被绕过（使用大小写变种、编码绕过等）
- 不同开发人员对SQL安全的理解不一致

**来源**：Epic §3.1 风险1 SQL注入安全

---

## 决策

### 核心方案选择

**采用分层防护策略**：
1. **前端黑名单**：拦截常见危险关键字（DROP/DELETE/ALTER等）
2. **后端PreparedStatement**：使用参数化查询，完全分离SQL和参数
3. **数据库只读账号**：专用只读账号执行查询，即使注入成功也无权修改
4. **代码审查**：所有SQL相关代码100%人工审查

**核心理由**：
采用"防线递进式"防护，即使某一层失效，后续防线仍可保护系统。PreparedStatement是行业标准，成熟度高，性能开销可忽略。来源：Epic §3.1 缓解方案。

---

## 候选方案

### SQL安全防护方案对比

| 维度 | 方案A：分层防护 | 方案B：仅黑名单 | 方案C：ORM框架 |
|------|---------------|-----------|---------  |
| **防护强度** | 高（4层防线） | 低（易绕过） | 中（取决于ORM） |
| **易用性** | 中（黑名单限制） | 高（几乎无限制） | 高（拖拽界面） |
| **性能开销** | 低（<1ms） | 低（<0.1ms） | 中（ORM反射） |
| **实现复杂度** | 中（4个模块） | 低（1个模块） | 高（学习ORM） |
| **绕过风险** | 低（编码/大小写绕过） | 高（编码/大小写/注释绕过） | 低（ORM强制转义） |
| **调试难度** | 中（可看到SQL） | 中（可看到SQL） | 高（ORM生成SQL） |
| **成本估算** | 2人日 | 0.5人日 | 8人日（学习+迁移） |

#### 详细方案说明

##### 方案A：分层防护（推荐）

**层级1：前端黑名单**
```javascript
// 前端JavaScript检查
const dangerousKeywords = ['DROP', 'DELETE', 'TRUNCATE', 'ALTER', 'INSERT', 'UPDATE', 'CREATE'];
function validateSQL(sql) {
  const upperSQL = sql.toUpperCase();
  for (const keyword of dangerousKeywords) {
    if (upperSQL.includes(keyword)) {
      return false; // 被拦截
    }
  }
  return true;
}
```

**优点**：快速反馈，改善用户体验，不让用户输入非法SQL  
**缺点**：易被绕过（关键字编码、注释插入等）

**层级2：后端PreparedStatement**
```java
// 后端Java使用PreparedStatement
String sql = "SELECT * FROM employees WHERE department_id = ? AND salary > ?";
PreparedStatement ps = connection.prepareStatement(sql);
ps.setInt(1, deptId);        // 参数1绑定为整数
ps.setBigDecimal(2, salary); // 参数2绑定为小数
ResultSet rs = ps.executeQuery();
```

**优点**：SQL和参数完全分离，无论参数包含什么内容都不会被作为SQL执行  
**缺点**：需要开发人员按规范编码，规范遗漏会导致风险

**层级3：数据库只读账号**
```sql
-- 创建只读账号，仅赋予SELECT权限
CREATE USER 'query_user'@'localhost' IDENTIFIED BY 'xxx';
GRANT SELECT ON database.* TO 'query_user'@'localhost';
REVOKE INSERT, UPDATE, DELETE ON database.* FROM 'query_user'@'localhost';
```

**优点**：即使SQL注入成功，攻击者也无权修改、删除数据  
**缺点**：需要额外的账号管理

**层级4：代码审查**
```
审查清单：
1. 所有数据库操作是否使用PreparedStatement？
2. 是否存在字符串拼接的SQL？
3. 是否有通过用户输入构建SQL的地方？
4. 参数绑定是否类型正确？
```

**优点**：抓住遗漏的规范，人工补漏  
**缺点**：依赖人工，容易遗漏

##### 方案B：仅黑名单

**工作原理**：前端和后端都检查SQL中是否包含危险关键字。

**❌ 劣势**：
1. 容易被编码绕过：`DR0P` (替换字母0) 或 `D/**/ROP` (注释插入)
2. 大小写变种：`drop` vs `DROP` vs `DrOp`
3. Unicode编码：`\u0044ROP` (U+0044 = 'D')
4. 多语言：中文"删除"不在黑名单中

**历史教训**：
- 2020年某财务系统被攻击，攻击者使用`/*...*/`注释绕过黑名单
- 2019年某电商系统被攻击，攻击者使用大小写混合`DrOp TaBlE`绕过

**风险等级**：🔴 高

##### 方案C：ORM框架（如MyBatis/Hibernate）

**工作原理**：使用高级框架，自动处理SQL生成和参数绑定。

**❌ 劣势**：
1. 学习成本高：MyBatis动态SQL复杂，学习曲线陡峭
2. 不适合此场景：用户输入的是任意SQL，不是固定的SQL模板
3. 无法灵活应对：用户可能需要复杂的WHERE条件组合，ORM难以满足

**结论**：ORM适合固定SQL场景，不适合本项目用户自定义SQL场景

---

## 权衡分析

### 方案A：分层防护（推荐）

**✅ 优势**：

1. **防护等级最高**：四层防线，即使某层失效仍有保护
   - 前端黑名单拦截99%的初级攻击
   - PreparedStatement完全阻止注入
   - 只读账号限制损害范围
   - 代码审查捕获遗漏
   - 来源：Epic §3.1 缓解方案 第1-4点

2. **成熟度高，风险低**：PreparedStatement是行业标准，已被广泛采用
   - OWASP推荐的首选防护方案
   - 性能开销<1ms，可忽略
   - Java/Python/PHP等各种语言都内置支持
   - 来源：业界标准实践

3. **不过度限制用户**：允许合法的复杂SELECT查询
   - 用户可以使用JOIN、子查询、聚合函数等
   - 相比"禁用所有JOIN"等方案更灵活
   - 来源：user story US-001 用户需求

4. **可调试性好**：开发人员可以看到生成的SQL
   - 便于性能分析和问题排查
   - 相比ORM的自动生成更透明
   - 来源：基于运维经验补充

**❌ 劣势**：

1. **实现工作量较大**：需要4个防护层的代码
   - 前端黑名单检查（0.25人日）
   - 后端PreparedStatement规范实施（0.5人日）
   - 数据库只读账号配置（0.25人日）
   - 代码审查流程建立（0.5人日）
   - 缓解措施：采用统一的工具函数库，降低重复代码（后端2小时）
   - 来源：Epic §1.2 工作量分布

2. **需要开发规范遵守**：如果开发人员不按规范，仍有漏洞
   - 容易出现字符串拼接SQL的代码
   - 缓解措施：代码审查100%覆盖，SonarQube静态扫描检测SQL拼接（配置1小时）
   - 来源：Epic §3.1 技术风险

3. **黑名单维护成本**：新的攻击手段出现时需要更新
   - 编码绕过、新关键字等
   - 缓解措施：定期（每周）更新黑名单，关注安全公告（0.5人天/周）
   - 来源：基于安全运维经验补充

### 方案B：仅黑名单

**✅ 优势**：

1. **实现快速**：仅需1个模块，0.5人日可完成
2. **性能开销最小**：<0.1ms，几乎无开销

**❌ 劣势**：

1. **防护强度弱**：多种编码和绕过方式可突破
   - 编码：`D/**/ROP TABLE users` 可绕过简单的关键字检查
   - 大小写混合：黑名单检查`DROP`，但用户输入`DrOp`不被检测
   - 来源：Epic §3.1 技术风险

2. **风险等级高**：可能导致数据泄露
   - 有真实案例表明纯黑名单防护不足
   - 来源：业界安全事件分析

3. **不满足安全目标**：违反Epic §1.1 "零P0级Bug"
   - 数据泄露和破坏属于P0级严重问题
   - 来源：Epic §1.1 SMART目标

---

## 后果

### 正面影响

1. **安全性大幅提升**：采用多层防护，SQL注入风险↓95%
   - 满足Epic §1.1"零P0级Bug"的安全目标
   - 可获得安全认证（如ISO 27001）的必备条件

2. **用户体验改善**：前端黑名单快速反馈，指导用户规范输入
   - 用户输入危险SQL时即时提示，改善输入体验
   - 代价：时间<1ms，不影响体验

3. **可维护性强**：代码审查流程建立，后续安全变更有据可循
   - 来源：Epic §3.1 技术风险评估

### 负面影响与风险

| 风险ID | 风险描述 | 概率 | 影响 | 等级 | 应对措施 |
|--------|---------|------|------|------|---------|
| R1 | 开发人员不遵守PreparedStatement规范，仍使用字符串拼接 | 中 | 高 | 🔴 | SonarQube自动检测SQL拼接（扫描1小时），代码审查100%覆盖（每个PR必审） |
| R2 | 黑名单不完整，遗漏某些新的攻击向量 | 低 | 高 | 🔴 | 定期更新黑名单（每周检查安全公告），渗透测试（Day 6） |
| R3 | 前端黑名单被禁用（用户修改浏览器代码） | 低 | 中 | 🟡 | 后端黑名单作为最后一道防线，保证安全 |
| R4 | 只读账号权限设置错误，仍有修改权限 | 低 | 高 | 🔴 | 权限审查清单（检查3项），DBA验证（15分钟） |
| R5 | 性能下降：参数绑定增加网络往返 | 低 | 低 | 🟢 | 网络往返次数不增加（数据库连接复用），性能影响<1%可忽略 |

---

## 回滚条件

### 触发条件（满足任一条件即触发防护机制评估）

#### 条件1：SQL注入漏洞

**量化指标**：发生任何成功的SQL注入攻击或渗透测试发现的注入漏洞

- **监控方式**：
  - 每日检查数据库操作审计日志（查找异常SQL模式）
  - 渗透测试（Day 6）尝试注入攻击
  - 代码审查时特别检查SQL相关代码

- **判定周期**：实时（发现立即上报）

- **责任人**：安全审查团队

- **触发阈值**：
  ```
  IF (sql_injection_vulnerability_detected == true) THEN immediate escalation
  ```

#### 条件2：黑名单被绕过

**量化指标**：代码审查或渗透测试发现黑名单检查可被绕过（编码、注释、大小写等）

- **监控方式**：
  - 渗透测试尝试已知的绕过技术
  - 安全公告（OWASP）追踪新的绕过方式
  - 代码审查

- **判定周期**：每周一进行黑名单有效性评估

- **责任人**：安全审查团队

- **触发阈值**：
  ```
  IF (blacklist_bypass_detected == true) THEN update blacklist + execute immediate fix
  ```

#### 条件3：规范遵守不足

**量化指标**：代码审查发现超过5%的SQL相关代码不使用PreparedStatement

- **监控方式**：
  - SonarQube规则检测：`sql-statement-without-prepared-statement`
  - 代码审查时计数不规范的代码
  - 定期扫描（每周）

- **判定周期**：每周一进行合规性评估

- **责任人**：代码审查者

- **触发阈值**：
  ```
  IF (non_compliant_sql_code_ratio > 5%) THEN code review escalation
  ```

### 回滚/增强方案

#### 方案1：强化前端黑名单

**执行步骤**：
1. 添加编码检测（检查URL编码、Unicode编码）（预计1小时）
2. 添加注释过滤（检查`/**/`、`--`等注释符）（预计0.5小时）
3. 大小写标准化处理（预计0.5小时）
4. 回归测试（预计1小时）

**总执行时间**：3小时

**何时执行**：触发条件R1或R2

#### 方案2：加强代码审查流程

**执行步骤**：
1. 制定SQL审查清单（5项关键点）（预计1小时）
2. 配置SonarQube规则自动检测（预计1小时）
3. 将SQL审查加入Code Review的Checklist（预计0.5小时）
4. 团队培训（预计1小时）

**总执行时间**：3.5小时

**何时执行**：触发条件R1或R3

#### 方案3：提升数据库账号权限管理

**执行步骤**：
1. 审查所有数据库账号的权限配置（预计2小时）
2. 创建专用审计账号用于监控（预计1小时）
3. 实施权限分离（只读/读写/管理）（预计2小时）
4. 权限审查和测试（预计2小时）

**总执行时间**：7小时

**何时执行**：触发条件R4（权限设置错误）

---

## 实施路线图

### 第1阶段：基础实施（Day 1-2）

```
1. 前端黑名单开发（0.25人日）
2. 后端PreparedStatement规范编写（0.5人日）
3. 数据库只读账号创建（0.25人日）
4. 代码审查清单制定（0.25人日）
```

### 第2阶段：集成验证（Day 3）

```
1. 所有SQL相关代码100%审查（0.5人日）
2. SonarQube配置和首次扫描（0.25人日）
3. 功能测试验证（0.25人日）
```

### 第3阶段：安全测试（Day 6）

```
1. 渗透测试（尝试注入攻击）（0.5人日）
2. 黑名单有效性评估（0.25人日）
3. 安全报告和改进（0.25人日）
```

### 持续运维（后续）

```
每周：检查安全公告，更新黑名单
每月：安全审计日志，评估安全态势
```

---

## 相关文档

- **需求文档**：[Epic分析 §3.1 技术风险评估](./doc/prompts/Epic分析-程序员报表生成工具.md)
- **用户故事**：[US-002 查询安全校验](./doc/用户故事拆解-程序员报表生成工具MVP.md)
- **技术实施**：【待编写】SQL安全防护实施指南
- **测试计划**：【待编写】安全测试计划（Day 6）
- **代码示例**：【待编写】PreparedStatement使用规范
- **审查清单**：【待执行】SQL代码审查Checklist

---

**文档状态**：✅ 已接受 | **最后更新**：2025-12-26 | **审核人**：安全审查团队
